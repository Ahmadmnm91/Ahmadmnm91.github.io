<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Viewer with Adjustments</title>
    <style>
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        .slider-container {
            width: 500px;
            display: flex;
            justify-content: center;
            order: 2;
        }
        input[type="range"].horizontal {
            width: 100%;
        }
        .error-message {
            color: red;
            font-size: 18px;
            text-align: center;
            margin: 20px;
        }
        #imageCanvas {
            cursor: move;
        }
        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
            width: 100%;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 5px;
            background-color: #f5f5f5;
            border-radius: 4px;
        }
        .control-label {
            min-width: 100px;
            font-weight: bold;
        }
        .control-slider {
            flex-grow: 1;
        }
        .control-value {
            min-width: 50px;
            text-align: right;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div class="container">
        <canvas id="imageCanvas" width="500" height="500"></canvas>
        <div class="controls">
            <div class="control-group">
                <span class="control-label">Image:</span>
                <input type="range" id="imageSlider" class="control-slider horizontal" min="0" value="0" step="1">
            </div>
            <div class="control-group">
                <span class="control-label">Brightness:</span>
                <input type="range" id="brightnessSlider" class="control-slider" min="-100" max="100" value="0" step="1">
                <span class="control-value" id="brightnessValue">0</span>
            </div>
            <div class="control-group">
                <span class="control-label">Contrast:</span>
                <input type="range" id="contrastSlider" class="control-slider" min="-100" max="100" value="0" step="1">
                <span class="control-value" id="contrastValue">0</span>
            </div>
            <div class="control-group">
                <span class="control-label">Gamma:</span>
                <input type="range" id="gammaSlider" class="control-slider" min="1" max="22" value="10" step="1">
                <span class="control-value" id="gammaValue">1.0</span>
            </div>
            <div class="control-group">
                <span class="control-label">Sharpness:</span>
                <input type="range" id="sharpnessSlider" class="control-slider" min="0" max="100" value="0" step="1">
                <span class="control-value" id="sharpnessValue">0</span>
            </div>
            <div class="control-group">
                <span class="control-label">Rotation:</span>
                <input type="range" id="rotationSlider" class="control-slider" min="0" max="360" value="0" step="1">
                <span class="control-value" id="rotationValue">0Â°</span>
            </div>
        </div>
    </div>
    <div id="errorMessage" class="error-message"></div>
     <script>
        let images = [];
        let imageUrls = []; // Store URLs for cleanup
        let offscreenCanvas = null;
        let offscreenCtx = null;
        let currentImageIndex = 0;
        let scale = 1;
        let offsetX = 0;
        let offsetY = 0;
        let isDragging = false;
        let lastX = 0;
        let lastY = 0;
        let prevDistance = 0;
        let prevScale = 1;
        let requestAnimationFrameId = null;
        let isImageProcessingPending = false;

        const imageAdjustments = {
            brightness: 0,
            contrast: 0,
            gamma: 1.0,
            sharpness: 0,
            rotation: 0
        };

        // Convolution kernels
        const sharpenKernel = new Float32Array([
            -1, -1, -1,
            -1,  9, -1,
            -1, -1, -1
        ]);

        async function fetchBinFile(filePath) {
            try {
                const response = await fetch(filePath);
                if (!response.ok) throw new Error('File not found');
                return await response.arrayBuffer();
            } catch (error) {
                throw new Error('Failed to load file');
            }
        }

        function cleanupImages() {
            // Revoke object URLs to free memory
            imageUrls.forEach(url => URL.revokeObjectURL(url));
            imageUrls = [];
            
            // Clear image array
            images = [];
            
            // Force garbage collection hint
            if (window.gc) window.gc();
        }

        function loadImagesFromBuffer(buffer) {
            cleanupImages(); // Cleanup existing images

            const dataView = new DataView(buffer);
            let offset = 0;
            const fileCount = dataView.getInt32(offset, true);
            offset += 4;

            const imgs = [];
            const promises = [];

            for (let i = 0; i < fileCount; i++) {
                const jpegDataLength = dataView.getInt32(offset, true);
                offset += 4;
                const jpegData = new Uint8Array(buffer, offset, jpegDataLength);
                offset += jpegDataLength;

                const blob = new Blob([jpegData], { type: 'image/jpeg' });
                const imageUrl = URL.createObjectURL(blob);
                imageUrls.push(imageUrl); // Store URL for later cleanup

                const image = new Image();
                image.src = imageUrl;
                imgs.push(image);
                
                promises.push(new Promise(resolve => {
                    image.onload = resolve;
                }));
            }

            // Free the original buffer
            buffer = null;

            return Promise.all(promises).then(() => imgs);
        }

        function initOffscreenCanvas(width, height) {
            if (offscreenCanvas) {
                offscreenCanvas.width = width;
                offscreenCanvas.height = height;
            } else {
                offscreenCanvas = new OffscreenCanvas(width, height);
                offscreenCtx = offscreenCanvas.getContext('2d', {
                    willReadFrequently: true
                });
            }
        }

        function applyConvolution(data, width, height, kernel, kernelSize) {
            const output = new Uint8ClampedArray(data.length);
            const half = Math.floor(kernelSize / 2);
            const lineSize = width * 4;
            const kernelTotal = kernel.reduce((a, b) => a + b, 0);

            // Process alpha channel separately
            for (let i = 3; i < data.length; i += 4) {
                output[i] = data[i];
            }

            // Use TypedArrays for better performance
            const tempR = new Float32Array(width * height);
            const tempG = new Float32Array(width * height);
            const tempB = new Float32Array(width * height);

            // Process each channel separately for better memory usage
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    let r = 0, g = 0, b = 0;

                    for (let ky = -half; ky <= half; ky++) {
                        const iy = y + ky;
                        if (iy >= 0 && iy < height) {
                            for (let kx = -half; kx <= half; kx++) {
                                const ix = x + kx;
                                if (ix >= 0 && ix < width) {
                                    const kernelIdx = (ky + half) * kernelSize + (kx + half);
                                    const dataIdx = (iy * width + ix) * 4;
                                    
                                    r += data[dataIdx] * kernel[kernelIdx];
                                    g += data[dataIdx + 1] * kernel[kernelIdx];
                                    b += data[dataIdx + 2] * kernel[kernelIdx];
                                }
                            }
                        }
                    }

                    tempR[y * width + x] = r;
                    tempG[y * width + x] = g;
                    tempB[y * width + x] = b;
                }
            }

            // Write back to output buffer
            for (let i = 0; i < width * height; i++) {
                const idx = i * 4;
                output[idx] = Math.min(255, Math.max(0, tempR[i]));
                output[idx + 1] = Math.min(255, Math.max(0, tempG[i]));
                output[idx + 2] = Math.min(255, Math.max(0, tempB[i]));
            }

            return output;
        }

        function processImageData(imageData) {
            if (!imageData) return null;

            const data = imageData.data;
            let processed = new Uint8ClampedArray(data);

            if (imageAdjustments.sharpness > 0) {
                const intensity = imageAdjustments.sharpness / 100;
                const customKernel = new Float32Array([
                    -intensity, -intensity, -intensity,
                    -intensity, 1 + (8 * intensity), -intensity,
                    -intensity, -intensity, -intensity
                ]);
                processed = applyConvolution(processed, imageData.width, imageData.height, customKernel, 3);
            }

            // Process in chunks to avoid blocking the main thread
            const chunkSize = 50000;
            const chunks = Math.ceil(data.length / chunkSize);

            return new Promise(resolve => {
                let currentChunk = 0;

                function processChunk() {
                    const start = currentChunk * chunkSize;
                    const end = Math.min(start + chunkSize, data.length);

                    for (let i = start; i < end; i += 4) {
                        let r = processed[i];
                        let g = processed[i + 1];
                        let b = processed[i + 2];

                        // Apply adjustments
                        r = Math.min(255, Math.max(0, applyAdjustments(r)));
                        g = Math.min(255, Math.max(0, applyAdjustments(g)));
                        b = Math.min(255, Math.max(0, applyAdjustments(b)));

                        processed[i] = r;
                        processed[i + 1] = g;
                        processed[i + 2] = b;
                    }

                    currentChunk++;

                    if (currentChunk < chunks) {
                        requestAnimationFrameId = requestAnimationFrame(processChunk);
                    } else {
                        resolve(processed);
                    }
                }

                processChunk();
            });
        }

        function applyAdjustments(value) {
            // Brightness
            value += imageAdjustments.brightness;

            // Contrast
            const factor = (259 * (imageAdjustments.contrast + 255)) / (255 * (259 - imageAdjustments.contrast));
            value = factor * (value - 128) + 128;

            // Gamma
            value = 255 * Math.pow(value / 255, 1 / imageAdjustments.gamma);

            return value;
        }

        async function displayImage(image) {
            if (!image || isImageProcessingPending) return;
            isImageProcessingPending = true;

            const canvas = document.getElementById('imageCanvas');
            const ctx = canvas.getContext('2d', {
                alpha: false,
                willReadFrequently: true
            });

            // Initialize or resize offscreen canvas
            initOffscreenCanvas(image.width, image.height);

            // Clear canvases
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            offscreenCtx.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);

            // Draw image to offscreen canvas
            offscreenCtx.drawImage(image, 0, 0);

            // Process image data
            const imageData = offscreenCtx.getImageData(0, 0, offscreenCanvas.width, offscreenCanvas.height);
            const processedData = await processImageData(imageData);

            // Put processed data back to offscreen canvas
            offscreenCtx.putImageData(new ImageData(processedData, offscreenCanvas.width, offscreenCanvas.height), 0, 0);

            // Draw to main canvas with transformations
            ctx.save();
            ctx.translate(canvas.width/2, canvas.height/2);
            ctx.rotate(imageAdjustments.rotation * Math.PI / 180);
            ctx.scale(scale, scale);
            ctx.translate(offsetX/scale, offsetY/scale);
            ctx.drawImage(offscreenCanvas, -image.width/2, -image.height/2, image.width, image.height);
            ctx.restore();

            isImageProcessingPending = false;
        }

        // ... (rest of the event handling code remains the same) ...

        async function init() {
            try {
                const urlParams = new URLSearchParams(window.location.search);
                const binFileName = urlParams.get('file');
                const filePath = binFileName ? `Images/${binFileName}.bin` : 'Images/output.bin';

                const buffer = await fetchBinFile(filePath);
                images = await loadImagesFromBuffer(buffer);

                if (images.length > 0) {
                    const slider = document.getElementById('imageSlider');
                    slider.max = images.length - 1;
                    await displayImage(images[0]);

                    slider.addEventListener('input', (e) => {
                        currentImageIndex = parseInt(e.target.value);
                        displayImage(images[currentImageIndex]);
                    });

                    setupCanvasEvents();
                    setupAdjustmentSliders();
                }
            } catch (error) {
                showError('Error: The requested image file was not found or could not be loaded.');
            }
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (requestAnimationFrameId) {
                cancelAnimationFrame(requestAnimationFrameId);
            }
            cleanupImages();
        });

        window.onload = init;
    </script>
</body>
</html>
