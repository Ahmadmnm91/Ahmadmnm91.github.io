<!DOCTYPE html>
<html>
<head>
    <title>Binary Image Loader with URL Input</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; margin-top: 20px; }
        #container { display: inline-block; position: relative; }
        #imageCanvas { border: 1px solid #ccc; margin-top: 20px; cursor: grab; }
        .controls { margin-top: 20px; display: inline-block; text-align: left; }
        .button-container { margin-top: 10px; text-align: center; }
        button { padding: 10px 20px; margin: 5px; }
        .slider-container { margin-top: 10px; }
        .slider-container label { display: inline-block; width: 100px; }
        .slider-container input { width: 300px; }
        .slider-container span { margin-left: 10px; }
        #imageCounter { margin-top: 10px; font-weight: bold; text-align: center; }
        #urlInput { width: 500px; padding: 5px; margin-top: 10px; }
    </style>
</head>
<body>
    <h1>Load Images from Binary File</h1>
    <!-- File Input -->
    <input type="file" id="fileInput" accept=".bin">
    <p>OR</p>
    <!-- URL Input and Button -->
    <input type="text" id="urlInput" placeholder="Enter URL of .bin file">
    <button id="loadUrlButton">Load from URL</button>

    <div id="container">
        <canvas id="imageCanvas" width="800" height="600"></canvas>
    </div>

    <div class="controls">
        <div class="button-container">
            <button id="prevButton">Previous</button>
            <button id="nextButton">Next</button>
        </div>
        <p id="imageCounter"></p>
        <div class="slider-container">
            <label for="brightnessSlider">Brightness:</label>
            <input type="range" id="brightnessSlider" min="0" max="200" value="100">
            <span id="brightnessValue">100%</span>
        </div>
        <div class="slider-container">
            <label for="contrastSlider">Contrast:</label>
            <input type="range" id="contrastSlider" min="0" max="200" value="100">
            <span id="contrastValue">100%</span>
        </div>
        <div class="slider-container">
            <label for="gammaSlider">Gamma:</label>
            <input type="range" id="gammaSlider" min="10" max="300" value="100">
            <span id="gammaValue">1.00</span>
        </div>
        <div class="slider-container">
            <label for="rotationSlider">Rotation:</label>
            <input type="range" id="rotationSlider" min="0" max="360" value="0">
            <span id="rotationValue">0°</span>
        </div>
        <div class="slider-container">
            <label for="sharpenSlider">Sharpen:</label>
            <input type="range" id="sharpenSlider" min="0" max="1000" value="0">
            <span id="sharpenValue">0%</span>
        </div>
        <div class="button-container">
            <button id="resetButton">Reset Adjustments</button>
        </div>
    </div>

    <!-- Include the script at the end of the body -->
    <script>
        'use strict';

        let images = [];
        let currentIndex = 0;
        let brightness = 100; // Percentage
        let contrast = 100;   // Percentage
        let gamma = 1.0;      // Gamma value
        let rotation = 0;     // Degrees
        let sharpen = 0;      // Sharpen intensity (percentage, up to 1000%)

        let zoom = 1.0;       // Zoom level
        const minZoom = 0.5;
        const maxZoom = 5;
        const zoomStep = 0.1;

        let panX = 0;
        let panY = 0;
        let isPanning = false;
        let startX = 0;
        let startY = 0;

        // Function to load images from a binary buffer
        function loadImagesFromBuffer(buffer) {
            const dataView = new DataView(buffer);

            let offset = 0;
            const fileCount = dataView.getInt32(offset, true);
            offset += 4;

            const imgs = [];

            for (let i = 0; i < fileCount; i++) {
                const jpegDataLength = dataView.getInt32(offset, true);
                offset += 4;

                const jpegData = new Uint8Array(buffer, offset, jpegDataLength);
                offset += jpegDataLength;

                const blob = new Blob([jpegData], { type: 'image/jpeg' });
                const imageUrl = URL.createObjectURL(blob);

                const image = new Image();
                image.src = imageUrl;
                imgs.push(image);
            }

            return imgs;
        }

        // Function to display the current image on the canvas
        function displayImage() {
            if (images.length > 0 && currentIndex >= 0 && currentIndex < images.length) {
                const image = images[currentIndex];
                const canvas = document.getElementById('imageCanvas');
                const ctx = canvas.getContext('2d');
                const canvasWidth = canvas.width;
                const canvasHeight = canvas.height;

                // Update the image counter
                document.getElementById('imageCounter').textContent = `Image ${currentIndex + 1} of ${images.length}`;

                // Function to draw the image with current adjustments
                function draw() {
                    ctx.clearRect(0, 0, canvasWidth, canvasHeight);

                    // Create an off-screen canvas for image adjustments
                    const offCanvas = document.createElement('canvas');
                    const offCtx = offCanvas.getContext('2d');
                    offCanvas.width = image.width;
                    offCanvas.height = image.height;
                    offCtx.drawImage(image, 0, 0);

                    // Get image data
                    let imageData = offCtx.getImageData(0, 0, offCanvas.width, offCanvas.height);
                    let data = imageData.data;

                    // Adjustments
                    const brightnessFactor = brightness / 100;
                    const contrastFactor = contrast / 100;
                    const gammaCorrection = 1 / gamma;

                    for (let i = 0; i < data.length; i += 4) {
                        // Apply brightness and contrast
                        data[i] = ((((data[i] - 128) * contrastFactor) + 128) * brightnessFactor);       // Red
                        data[i + 1] = ((((data[i + 1] - 128) * contrastFactor) + 128) * brightnessFactor); // Green
                        data[i + 2] = ((((data[i + 2] - 128) * contrastFactor) + 128) * brightnessFactor); // Blue

                        // Apply gamma correction
                        data[i] = 255 * Math.pow(data[i] / 255, gammaCorrection);
                        data[i + 1] = 255 * Math.pow(data[i + 1] / 255, gammaCorrection);
                        data[i + 2] = 255 * Math.pow(data[i + 2] / 255, gammaCorrection);
                    }

                    // Ensure values are within [0,255]
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = Math.min(255, Math.max(0, data[i]));       // Red
                        data[i + 1] = Math.min(255, Math.max(0, data[i + 1])); // Green
                        data[i + 2] = Math.min(255, Math.max(0, data[i + 2])); // Blue
                        // Alpha channel remains unchanged
                    }

                    // Apply sharpen filter if sharpen intensity > 0
                    if (sharpen > 0) {
                        imageData = applySharpenFilter(offCtx, imageData, sharpen);
                    }

                    // Put adjusted image data back onto the off-screen canvas
                    offCtx.putImageData(imageData, 0, 0);

                    // Calculate rotation in radians
                    const angleRad = rotation * Math.PI / 180;

                    // Save context state
                    ctx.save();

                    // Apply pan and zoom
                    ctx.translate(panX, panY);
                    ctx.scale(zoom, zoom);

                    // Move to center and rotate
                    ctx.translate(canvasWidth / (2 * zoom), canvasHeight / (2 * zoom));
                    ctx.rotate(angleRad);

                    // Draw the image centered at the origin
                    ctx.drawImage(offCanvas, -image.width / 2, -image.height / 2);

                    // Restore context state
                    ctx.restore();
                }

                // If the image is already loaded, draw it immediately
                if (image.complete) {
                    draw();
                } else {
                    image.onload = draw;
                }
            } else {
                alert('No images to display.');
            }
        }

        // Sharpen filter function for higher intensities
        function applySharpenFilter(ctx, imageData, intensity) {
            const width = imageData.width;
            const height = imageData.height;
            const srcData = imageData.data;

            // Create a copy of the image data to store the output
            const output = ctx.createImageData(width, height);
            const dstData = output.data;

            // Base sharpen kernel
            const baseKernel = [
                0, -1,  0,
               -1,  5, -1,
                0, -1,  0
            ];

            // Adjust kernel based on intensity
            const factor = intensity / 100; // For intensity > 100%
            const kernel = baseKernel.map(value => value);

            // Increase the center value proportionally to the intensity
            kernel[4] = 5 + factor * 4; // Adjust center value

            // Apply convolution
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    let r = 0, g = 0, b = 0;

                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const weight = kernel[(ky + 1) * 3 + (kx + 1)];
                            const srcX = x + kx;
                            const srcY = y + ky;

                            const srcIndex = (srcY * width + srcX) * 4;

                            r += srcData[srcIndex] * weight;
                            g += srcData[srcIndex + 1] * weight;
                            b += srcData[srcIndex + 2] * weight;
                        }
                    }

                    const dstIndex = (y * width + x) * 4;

                    // Clamp convolution results
                    r = Math.min(255, Math.max(0, r));
                    g = Math.min(255, Math.max(0, g));
                    b = Math.min(255, Math.max(0, b));

                    dstData[dstIndex]     = r;
                    dstData[dstIndex + 1] = g;
                    dstData[dstIndex + 2] = b;
                    dstData[dstIndex + 3] = srcData[dstIndex + 3]; // Copy alpha channel
                }
            }

            return output;
        }

        // Event listener for file input
        document.getElementById('fileInput').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();

            reader.onload = function(e) {
                const buffer = e.target.result;
                images = loadImagesFromBuffer(buffer);
                currentIndex = 0;
                resetAdjustments();
                resetPanZoom();
                displayImage();
            };

            reader.onerror = function() {
                alert('Failed to read the file!');
            };

            reader.readAsArrayBuffer(file);
        });

        // Event listener for Load from URL button
        document.getElementById('loadUrlButton').addEventListener('click', function() {
            const url = document.getElementById('urlInput').value.trim();
            if (!url) {
                alert('Please enter a valid URL.');
                return;
            }

            fetch(url)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Network response was not ok: ${response.statusText}`);
                    }
                    return response.arrayBuffer();
                })
                .then(buffer => {
                    images = loadImagesFromBuffer(buffer);
                    currentIndex = 0;
                    resetAdjustments();
                    resetPanZoom();
                    displayImage();
                })
                .catch(error => {
                    console.error('Error fetching the .bin file:', error);
                    alert('Failed to load the .bin file from the URL. Check the console for details.');
                });
        });

        // Event listeners for Next and Previous buttons
        document.getElementById('nextButton').addEventListener('click', function() {
            if (currentIndex < images.length - 1) {
                currentIndex++;
                displayImage();
            } else {
                alert('This is the last image.');
            }
        });

        document.getElementById('prevButton').addEventListener('click', function() {
            if (currentIndex > 0) {
                currentIndex--;
                displayImage();
            } else {
                alert('This is the first image.');
            }
        });

        // Event listeners for sliders

        // Brightness Slider
        document.getElementById('brightnessSlider').addEventListener('input', function() {
            brightness = parseInt(this.value);
            document.getElementById('brightnessValue').textContent = brightness + '%';
            displayImage();
        });

        // Contrast Slider
        document.getElementById('contrastSlider').addEventListener('input', function() {
            contrast = parseInt(this.value);
            document.getElementById('contrastValue').textContent = contrast + '%';
            displayImage();
        });

        // Gamma Slider
        document.getElementById('gammaSlider').addEventListener('input', function() {
            gamma = parseFloat(this.value) / 100;
            document.getElementById('gammaValue').textContent = gamma.toFixed(2);
            displayImage();
        });

        // Rotation Slider
        document.getElementById('rotationSlider').addEventListener('input', function() {
            rotation = parseInt(this.value);
            document.getElementById('rotationValue').textContent = rotation + '°';
            displayImage();
        });

        // Sharpen Slider
        document.getElementById('sharpenSlider').addEventListener('input', function() {
            sharpen = parseInt(this.value);
            document.getElementById('sharpenValue').textContent = sharpen + '%';
            displayImage();
        });

        // Event listener for reset button
        document.getElementById('resetButton').addEventListener('click', function() {
            resetAdjustments();
            resetPanZoom();
            displayImage();
        });

        // Function to reset adjustments
        function resetAdjustments() {
            brightness = 100;
            contrast = 100;
            gamma = 1.0;
            rotation = 0;
            sharpen = 0;

            document.getElementById('brightnessSlider').value = 100;
            document.getElementById('contrastSlider').value = 100;
            document.getElementById('gammaSlider').value = 100;
            document.getElementById('rotationSlider').value = 0;
            document.getElementById('sharpenSlider').value = 0;

            document.getElementById('brightnessValue').textContent = '100%';
            document.getElementById('contrastValue').textContent = '100%';
            document.getElementById('gammaValue').textContent = '1.00';
            document.getElementById('rotationValue').textContent = '0°';
            document.getElementById('sharpenValue').textContent = '0%';
        }

        // Zoom and Pan Event Listeners
        const canvas = document.getElementById('imageCanvas');

        canvas.addEventListener('wheel', function(event) {
            event.preventDefault();
            const delta = event.deltaY > 0 ? -zoomStep : zoomStep;
            const newZoom = Math.min(maxZoom, Math.max(minZoom, zoom + delta));

            // Adjust pan to zoom towards mouse position
            const rect = canvas.getBoundingClientRect();
            const mouseX = (event.clientX - rect.left - panX) / zoom;
            const mouseY = (event.clientY - rect.top - panY) / zoom;

            panX -= (mouseX * (newZoom - zoom));
            panY -= (mouseY * (newZoom - zoom));

            zoom = newZoom;
            displayImage();
        });

        canvas.addEventListener('mousedown', function(event) {
            isPanning = true;
            startX = event.clientX - panX;
            startY = event.clientY - panY;
            canvas.style.cursor = 'grabbing';
        });

        canvas.addEventListener('mousemove', function(event) {
            if (isPanning) {
                panX = event.clientX - startX;
                panY = event.clientY - startY;
                displayImage();
            }
        });

        canvas.addEventListener('mouseup', function() {
            isPanning = false;
            canvas.style.cursor = 'grab';
        });

        canvas.addEventListener('mouseleave', function() {
            isPanning = false;
            canvas.style.cursor = 'grab';
        });

        // Function to reset pan and zoom
        function resetPanZoom() {
            zoom = 1.0;
            panX = 0;
            panY = 0;
        }
    </script>
</body>
</html>
